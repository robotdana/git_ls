# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/fast_ignore/all/fast_ignore.rbi
#
# fast_ignore-0.15.2

class FastIgnore
  def ===(path, directory: nil, content: nil); end
  def allowed?(path, directory: nil, content: nil); end
  def each(&block); end
  def each_recursive(parent_full_path, parent_relative_path, &block); end
  def initialize(relative: nil, root: nil, gitignore: nil, follow_symlinks: nil, **rule_set_builder_args); end
  def load_gitignore(parent_path, check_exists: nil); end
  def load_gitignore_recursive(path); end
  def to_proc; end
  include Enumerable
end
module FastIgnore::Backports
end
class FastIgnore::RuleSets
  def allowed_recursive?(relative_path, full_path, filename, content); end
  def allowed_unrecursive?(relative_path, dir, full_path, filename); end
  def append_and_return_if_present(value); end
  def append_root_gitignore(gitignore); end
  def append_set_from_array(rules, allow: nil, expand_path_with: nil); end
  def append_sets_from_files(files, allow: nil); end
  def append_subdir_gitignore(relative_path:, check_exists: nil); end
  def build_from_root_gitignore_file(path); end
  def build_rule_set(rules, allow, expand_path_with: nil, file_root: nil, gitignore: nil, squash: nil); end
  def build_set_from_file(filename, allow: nil, gitignore: nil, check_exists: nil, squash: nil); end
  def initialize(root:, ignore_rules: nil, ignore_files: nil, gitignore: nil, include_rules: nil, include_files: nil, argv_rules: nil); end
end
class FastIgnore::RuleSet
  def <<(other); end
  def allowed_recursive?(relative_path, dir, full_path, filename, content = nil); end
  def allowed_unrecursive?(relative_path, dir, full_path, filename, content); end
  def dir_rules; end
  def empty?; end
  def file_rules; end
  def gitignore?; end
  def has_shebang_rules; end
  def initialize(rules, allow, gitignore, squash = nil); end
  def squash_rules(rules); end
  def weight; end
end
module FastIgnore::GlobalGitignore
  def self.default_global_gitignore_path; end
  def self.gitconfig_gitignore_path(config_path); end
  def self.path(root:); end
  def self.xdg_config_home; end
  def self.xdg_config_home?; end
  def self.xdg_config_path; end
end
module FastIgnore::RuleBuilder
  def self.build(rule, allow, expand_path_with, file_root); end
  def self.gitignore_rules(rule, allow, file_root, expand_path_with = nil); end
  def self.shebang_rules(shebang, allow, file_root); end
end
class FastIgnore::GitignoreRuleBuilder
  def anchored!; end
  def anchored_or_file_path; end
  def blank!; end
  def break!; end
  def build; end
  def build_rule; end
  def dir_only!; end
  def emit_dir; end
  def emit_end; end
  def initialize(rule, file_path); end
  def negated!; end
  def never_anchored!; end
  def nothing_emitted?; end
  def prefix; end
  def process_backslash; end
  def process_character_class; end
  def process_end; end
  def process_rule; end
  def process_slash; end
  def process_star_end_after_slash; end
  def process_two_stars; end
  def unmatchable_rule!; end
end
class FastIgnore::GitignoreIncludeRuleBuilder < FastIgnore::GitignoreRuleBuilder
  def build_child_file_rule; end
  def build_parent_dir_rule; end
  def build_rule; end
  def emit_dir; end
  def emit_end; end
  def expand_rule_path; end
  def initialize(rule, file_path, expand_path_from = nil); end
  def negated!; end
  def nothing_emitted?; end
  def parent_dir_re; end
  def process_rule; end
  def unmatchable_rule!; end
end
class FastIgnore::GitignoreRuleRegexpBuilder < String
  def append(value); end
  def append_any_dir; end
  def append_any_non_dir; end
  def append_character_class_close; end
  def append_character_class_dash; end
  def append_character_class_negation; end
  def append_character_class_open; end
  def append_dir; end
  def append_end_anchor; end
  def append_end_dir_or_anchor; end
  def append_escaped(value); end
  def append_many_non_dir; end
  def append_one_non_dir; end
  def append_start_anchor; end
  def append_start_dir_or_anchor; end
  def to_regexp; end
end
class FastIgnore::GitignoreRuleScanner < StringScanner
  def backslash?; end
  def character_class_end?; end
  def character_class_literal; end
  def character_class_negation?; end
  def character_class_start?; end
  def dash?; end
  def end?; end
  def exclamation_mark?; end
  def hash?; end
  def literal; end
  def next_character; end
  def question_mark?; end
  def significant_whitespace; end
  def slash?; end
  def star?; end
  def star_end?; end
  def two_stars?; end
end
class FastIgnore::FileRoot
  def escaped; end
  def escaped_segments; end
  def escaped_segments_joined; end
  def escaped_segments_length; end
  def initialize(file_root); end
  def self.build(file_path, project_root); end
  def shebang_path_pattern; end
end
class FastIgnore::Rule
  def component_rules; end
  def component_rules_count; end
  def dir_only?; end
  def file_only?; end
  def initialize(rule, negation, anchored, dir_only, component_rules = nil); end
  def inspect; end
  def match?(relative_path, _full_path, _filename, _content); end
  def negation?; end
  def rule; end
  def shebang?; end
  def squash(rules); end
  def squashable_type; end
end
class FastIgnore::UnmatchableRule
  def self.component_rules_count; end
  def self.dir_only?; end
  def self.file_only?; end
  def self.inspect; end
  def self.match?(_relative_path, _full_path, _filename, _content); end
  def self.shebang?; end
  def self.squash(_); end
  def self.squashable_type; end
end
class FastIgnore::ShebangRule
  def component_rules_count; end
  def dir_only?; end
  def file_only?; end
  def file_path_pattern; end
  def first_line(path); end
  def initialize(rule, negation, file_path_pattern); end
  def inspect; end
  def match?(relative_path, full_path, filename, content); end
  def negation?; end
  def rule; end
  def shebang?; end
  def squash(rules); end
  def squashable_type; end
end
class FastIgnore::Error < StandardError
end
